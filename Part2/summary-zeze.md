# 2부 벽돌부터 시작하기: 프로그래밍 패러다임
(PART II Starting with the Bricks: Programming Paradigms)	

## 3장 패러다임 개요
### 구조적 프로그래밍
최초로 적용된 패러다임\
Edsger Wybe Dijkstra 가 발견.\
구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.
### 객체지향 프로그래밍
두번째로 도입된 패러다임\
Ole Johan Dahl, Kristen Nygaard 에 의해 등장.\
객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.
### 함수형 프로그래밍
최근에 도입되기 시작했지만, 세 패러다임중 가장 먼저 만들어짐\
Alonzo Church 에 의해 람다 계산법이 발명되었고, 이를 근간으로 Jogn McCarthy 가 LISP 언어를 만들었다.\
함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
### 생각할 거리
각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 무엇을 해야 할지 보다 무엇을 해서는 안되는지를 말해준다.\
세 가지 패러다임 각각은 우리에게 goto 문, 함수 포인터, 할당문을 앗아간다.\
더 빼앗아 갈 수 있는 것이 없으므로 부정적인 의도를 가진 패러다임으로는 이 세 가지가 전부일 것이다.\
이 패러다임은 1958-1968 에 걸쳐 10년동안 모두 만들어졌고, 새롭게 등장한 패러다임은 없다.
### 결론
세 가지 패러다임과 아키텍처의 세 가지 큰 관심사 (함수, 컴포넌트 분리, 데이터 관리) 가 어떻게 서로 연관되는지 주목하자.

## 4장 구조적 프로그래밍
### 증명
데이크스트라는 프로그래밍이 어렵고, 프로그래머가 프로그래밍을 잘하지 못한다는 사실을 해결하고자 했다.\
증명이라는 수학적 원리를 적용하여 이를 해결하고자 했고, 그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다.\
이를 사용하여 프로그래머가 스스로 코드가 올바름을 증명할 수 있게 하고자 했다.\
이 과정에서 단순한 알고리즘에 대해 기본적인 증명을 작성할 수 있는 연구를 하다가 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 될수 있음을 발견했다.\
모듈을 분해할 수 없다면 분할 정복 접근법 사용이 어렵다.\
goto 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우는 if 나 while 등의 분기와 반복이라는 단순한 제어구조에 해당한다는걸 발견했다.\
그리고 이러한 제어 구조는 순차 실행과 결합했을때 특별함을 깨달았다.\
뵘과 야코피니는 모든 프로그램을 순차, 분기, 반복 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.\
모듈을 증명하게하는 제어구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일함을 발견.\
다익스트라의 증명 방식
* 순차 구문 - 단순한 열거법 이용
* 분기 - 열거법을 재적용하는 방식. 분기를 통한 각 경로를 열거.
* 반복 - 귀납법을 사용. 열거법에 따라 1 의 경우가 올바름을 증명하고, N 의 경우가 올바르다고 가정할 때 N+1 의 경우도 올바름을 증명

### 해로운 성명서
데이크스트라는 goto문이 해롭다고 주장했고, 10년 이상의 논쟁 끝에 goto 문은 거의 사라졌다.\
현재의 우리 모두는 구조적 프로그래머이며, 여기에는 선택의 여지가 없다. 제어흐름을 제약없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.
### 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있게 되었다.\
거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해하고, 각 기능을 저수준의 함수들로 분해하는 과정을 끝없이 반복할 수 있다.\
이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용해 표현할 수 있다.
이를토대로 구조적 분석이나 구조적 설계같은 기법이 1970-1980 인기를 끌었다.\
이들 기법을 사용하면 대규모 시스템을 모듈과 컴포넌트, 더 나아가 아주 작은 기능들로 세분화할 수 있다.
### 엄밀한 증명은 없었다
데이크스트라가 원한 유클리드 계층구조는 만들어지지 않았고, 엄밀한 증명이 고품질의 소프트웨어를 만드는 올바른 방법이라고 믿는 프로그래머는 이제 거의 없다.\
대신 무언가가 올바른지 입증할때 사용하는 또 다른 전략으로 과학적 방법이 있다.
### 과학이 구출하다
과학이론과 법칙은 올바름을 절대로 증명할 수 없다는 점에서 과학은 수학과 근본적으로 다르다.\
과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.\
각고의 노력으로도 반례를 들기 어렵다면 목표에 부합할 만큼은 참이라고 본다.
### 테스트
데이크스트라 - "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"\
테스트에 충분히 노력을 들였다면 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있다.\
오히려 소프트웨어는 과학과 같다. 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.\
이러한 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있다. 예를들어 제약없는 goto 문을 사용하는 등 입증이 불가능한 프로그램은 테스트를 많이 수행하더라도 올바르다고 볼 수 없다.\
구조적 프로그램은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그리고 테스트를 통해 그 기능들이 거짓인지 증명하려고 시도한다.\
이런 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여길 수 있다.
### 결론
구조적 프로그래밍이 오늘늘까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 이 능력 때문이다.\
아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.\
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 (테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.\
이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.


## 5장 객체지향 프로그래밍
OO 란 무엇인가?\
데이터와 함수의 조합이라고 한다면 그다지 만족스러운 대답은 아니다. `o.f()` 가 `f(o)` 와 다르다는 의미를 내포하기 때문\
실제 세계를 모델링하는 새로운 방법이라는 대답은 의도나 정의가 모호하다.\
OO 의 본질을 설명하기 위해 세가지 주문에 기대는 부류도 있는데, 캡슐화, 상속, 다형성이 그것이다. 이들은 OO 가 이 셋을 적절하게 조합한 것이거나, 최소한 이 셋을 반드시 지원해야 한다고 한다.
### 캡슐화 (encapsulation)
OO 를 정의하는 요소중 하나인 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 OO 언어가 제공하기 때문이다.\
데이터와 함수가 일부는 은닉되고, 나머지는 노출되는 구분선을 지을 수 있다.\
OO 언어 뿐만 아니라 C 언어에서도 완벽한 캡슐화가 가능하다. 데이터 구조와 함수를 헤더 파일에 선언하고 구현 파일에서 이를 구현하는 방식이다.\
이후에 C++ 의 형태로 OO 가 등장했고, 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구했기 때문에 C 가 제공하던 캡슐화가 깨지게 되었다.\
언어에 private, public, protected 키워드를 도입해서 불완전한 캡슐화를 어느정도 보완하긴 했지만 임시 방편일 뿐이다.\
자바와 C# 은 헤더와 구현체를 분리하는 방식을 버렸고, 캡슐화는 더욱 심하게 훼손되었다.\
이때문에 OO 가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들며, 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.\
OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을거라는 믿음을 기반으로 한다.

### 상속 (inheritance)
상속만큼은 OO 언어가 확실히 제공했다.\
하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효범위로 묶어서 재정의하는 일에 불과하며, OO 언어 전에도 C 언어에서 상속과 비슷한 기법을 구현할 수 있었다.\
하지만 상속을 흉내내는 요령이고, 상속만큼은 편리한 방식은 아닌데다가 다중상속을 구현하기란 훨씬 더 어려운 일이었다.\
따라서 OO 언어가 완전히 새로운 개념을 만들진 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼수는 있다.

### 다형성 (polymorphism)
OO 이전에도 다형성을 표현할 수 있는 언어는 있었다.\
C 의 경우 함수의 포인터들을 가지는 struct 를 정의하고 이에 맞춰 struct 변수를 선언하면, 각 변수의 함수포인터가 가리키는 함수를 호출하는 식으로 구현된다.\
C++ 에서는 클래스의 모든 가상함수는 vtable 이라는 테이블에 포인터를 가지고 있고, 모든 가상함수 호출은 이 테이블을 거치게 된다.\
파생클래스의 생성자는 생성하려는 객체의 vtable 을 단순히 자신의 함수들로 덮어쓸 뿐이다.\
요지는 함수를 가리키는 포인터를 응용하느 것이 다형성이라는 점이다.\
OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀더 안전하고 편리하게 쓸수있게 해준다.\
함수 포인터를 직접 사용하는 방식의 문제는 함수포인터가 위험하다는 사실이다.\
이들 포인터를 초기화해야하며, 포인터를 통해 모든 함수를 호출해야한다. 이를 망각하면 버그가 발생하고, 찾고 고치기가 매우 힘들다.\
OO 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다.\
이러한 이유로 OO 는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

### 다형성이 가진 힘
복사 프로그램 예제를 보자. 새로운 입출력 장치가 생긴다면 프로그램에 어떤 변화가 생기는가?\
아무런 변경도 필요치 않다. 복사 프로그램의 소스코드는 입출력 드라이버의 소스코드에 의존하지 않기 때문이다.\
다시말해 입출력 드라이버가 복사 프로그램의 플러그인이 된 것이다.\
플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.\
그럼에도 대다수는 직접 작성하는 프로그램에서 이런 개념을 잘 적용하지 않았는데, 함수 포인터를 사용하는 것이 위험을 수반하기 때문이었다.\
OO 의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

### 의존성 역전
다형성을 안전하게 쓸 수 있는 메커니즘이 등정하기 전 소프트웨어의 모습\
전형적인 호출 트리어세 소스코드 의존성의 방향은 반드시 제어흐름을 따르게 된다 (flow of control)\
실제로 모든 호출 함수는 피호출함수가 포함된 모듈의 이름을 명시적으로 지정해야 한다.
이러한 제약조건으로 인해 아키텍트에게 남은 선택지는 별로 없었다.\
하지만 다형성이 끼어들면 특별한 일이 일어난다.
위 그림에서 HL1 은 ML1 모듈의 함수 F() 를 호출할 뿐이지만 ML1 과 I 인터페이스 사이의 소스코드 의존성 (상속관계)이 제어흐름과는 반대인 점을 주목하자.\
이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 심오한 의미를 갖는다.\
OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드 의존성을 어디서든 역전시킬 수 있다는 뜻이기도 하다.\
이러한 접근법을 사용한다면 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.\
즉 소스코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.\
이것이 OO 가 제공하는 힘이며 지향하는 것이다.\
그럼 이 힘으로 무엇을 할 수 있는가?\
예를 들어 업무 규칙이 DB 나 UI 에 의존하는 대신에, 소스코드 의존성을 반대로 배치하여 DB 와 UI 가 업무 규칙에 의존하게 만들 수 있다.\
즉, UI 와 DB 가 업무 규칙의 플러그인이 된다는 뜻이다. 다시말해 업무 규칙의 소스코드에서는 UI 나 DB 를 호출하지 않는다.\
세가지 컴포넌트는 배포 가능한 단위로 컴파일 할 수 있고 개별적이며 독립적으로 배포가 가능하다.\
각 컴포넌트는 배포 독립성과 개발 독립성을 가질 수 있다.

### 결론
OO 란 무엇인가?\
소프트웨어 아키텍트 관점에선 OO 란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
플러그인 아키텍쳐를 구성할 수 있고, 고수준의 모듈은 저수준의 모듈에 대해 독립성을 보장할 수 있으며 독립적으로 개발하고 배포할 수 있다.


## 6장 함수형 프로그래밍
이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했다

### 정수를 제곱하기
자바
```java
public class Squint {
    public static void main(String args[]) {
        for (int i = 0; i < 25; i++) {
            System.out.println(i*i);
        }
    }
}
```

클로져
```clojure
(println (take 25 (map (fn [x] (* x x)) (range))))
```

클로져와 자바의 극단적인 차이는 자바가 가변 변수를 사용한다는 것이다.\
클로저 프로그램에서는 이러한 가변 변수가 없고, x 와 같은 변수가 한 번 초기화 되면 절대로 변하지 않는다.\
함수형 언어에서 변수는 변경되지 않는다.\

### 불변성과 아키텍처
아키텍처를 고려할 때 이러한 내용이 왜 중요한가?\
경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변변수로 인해 발생한다.\
우리가 동시서 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.\
그렇다면 이제 불변성이 정말로 실현 가능한지를 스스로에게 반드시 물어봐야 한다.\
자원이 무한대가 아니라면 일종의 타협을 해야한다.

### 가변성의 분리
불변성과 관련하여 가장 주요한 타협중 하나는 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.\
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합조건 문제로부터 가변 변수를 보호한다.\
트랜잭션 메모리는 DB 가 디스크의 레코드를 다루는 방식과 동일한 방식 (트랜잭션 또는 재시도 기법) 으로 메모리의 변수를 처리한다.\
예를들어 compare and set 등.\
여러 변수가 상호 의존하는 상황에서는 더 정교한 장치를 사용해야한다.\
현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱
이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.\
지름길로 매일 자정에 상태를 계산해서 저장한 후 상태 정보가 필요해지면 자정 이후의 트랜잭션만을 처리하면 된다.\
저장 공간과 처리 능력이 충분하면 앱이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.\
소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.\

## 결론
* 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 부과되는 규율이다.
* 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 부과되는 규율이다.
* 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

이들 세 패러다임 모두 코드를 작성하는 방식의 형태를 한정시킨다.\
지난 반세기동안 우리가 배운것은 해서는 안 되는 것에 대해서다.\
소프트웨어의 핵심은 여전히 그대로고, 순차 분기, 반복, 참조로 구성된다.
