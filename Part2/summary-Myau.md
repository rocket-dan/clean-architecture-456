2부
==
3장: 패러다임 개요
--
1. 구조적 프로그래밍
    * 최초로 적용된 패러다임
    * 1968년 에츠허르 비버 데이크스트라는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시했다
    * 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

2. 객체 지향 프로그래밍
    * 1966년 올레 요한 달과 크리스텐 니가드에 의해 등장했다.
    * 함수 호출 스택 프레임으로 옮기면 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.
    * 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.
    * 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.
    * 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

3. 함수형 프로그래밍
    * 가장 먼저 만들어진 패러다임: 프로그래밍보다도 먼저.
    * 알론조 처치: 수학적 문제를 해결하는 과정에서 람다 계산법 발명
    * 1958 존 매카시가 만든 LISP 언어의 근간
    * 근간: 불변성, 심볼의 값이 변경되지 않는다
    * 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

1958년부터 1968년에 걸친 10년동안 모두 만들어졌고, 더 이상 앗아갈 것이 없다. ⇒ 다른 패러다임은 존재하지 않는다.

4장 구조적 프로그래밍
--
데이크스트라: 1952년 3월 네덜란드 최초의 프로그래머로 암스테르담의 수학센터에 취업, 마리아 데베츠와 결혼, 아드리안 반 베인가르덴-잘 할거야 우쭈쭈해줬다.
증명: 증명이라는 수학적인 원리로 프로그래밍을 해결하기로 했다. 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것
이를 통한 코드의 올바름을 스스로 증명하기 위해 노력.
연구 중 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 걸 발견. 분해할 수 없다면, 분할 정복 접근법을 사용할 수 없다.
if/then/else와, do/while과 같은 분기, 반복은 goto문을 사용해도 모듈 분해에 문제가 되지 않음.

제어 구조는 순차 실행과 결합했을 때 특별하다. 뵘과 야코피니가 데이크스트라보다 2년 앞서 모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조로 표현할 수 있다는 사실을 증명.
순차 구문: 단순한 열거법을 이용해 순차 구문이 올바름을 입증할 수 있다는 사실 증명. 수학적인 추적. 일반적 수학적 증명과 다를 바 없다.
분기: 열거법을 재적용. 분기를 통한 각 경로를 열거. 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.
반복: 귀납법을 사용해 증명. 1의 경우가 올바름을 증명. N의 경우가 올바르다고 가정하면 N+1도 올바름을 증명. 열거법을 사용.

CACM 3월호 "Go To Statement Considered Harmful"
현재의 우리 모두는 구조적 프로그래머이며, 제어흐름을 제약 없이 전환할 수 있는 선택권 자체를 언어에서 제공하지 않는다.
기능적 분해: 구조적 분석이나 구조적 설계 같은 기법이 1970년대 후반~1980년대에 걸쳐 인기를 끌었다. 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 이는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다 but 엄밀한 증명 실패.
과학적 방법: 올바름을 절대 증명할 수 없다. 시연 가능하고, 측정 가능하지만, 증명할 수 없다. 과학적 방법은 반증은 가능하지만 증명은 불가능하다. 서술이 틀렸음을 증명하는 방식으로 동작한다. 수학이 증명 가능한 서술이 참임을 입증하는 원리라면, 과학은 증명 가능한 서술이 거짓임을 입증하는 원리.
테스트: 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다. 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다. 소프트웨어는 과학과 같다.
결론: 구조적 프로그래밍이 가치 있는 이유는 반증 가능한 단위를 만들어낼 수 있기 때문이다.

TODO: 유클리드 계층구조가 뭐야 (대충은 알겠는데)
TODO: 천공카드 찍는데 이런 개념을 어떻게 쓰지

5장 객체 지향 프로그래밍
--
좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.
OO란? 누군가: "데이터와 함수의 조합", 만족스럽지 않은 대답. o.f()가 f(o)와 다른가
다른 누군가: "실제 세계를 모델링하는 새로운 방법"

세 가지 주문: 캡슐화, 상속, 다형성

  * 캡슐화: 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공. 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. private과 public 멤버 함수로 표현된다.
but, C에서 완벽한 캡슐화 가능. 사용자는 Point 구조체의 데이터 구조와 함수가 어떻게 구현되었는지 알 길이 없다. OO가 아니라도 충분히 가능. C++이라는 형태로 OO가 등장하며, C가 제공하던 완전한 캡슐화가 깨졌다. C++ 컴파일러는 기술적인 이유로 클래스 멤버 변수를 해당 클래스 헤더 파일에 선언할 것을 요구. 접근은 막지만, 헤더 파일은 멤버 변수를 알게 된다. public, private, protected를 도입하며 불완전한 캡슐화를 어느정도 보완했지만, 임시방편이다. 자바, C#은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 캡슐화는 더욱 심하게 훼손되었다. 클래스 선언과 정의 구분이 아예 불가능.
⇒ OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

  * 상속: 상속만큼은 OO가 확실히 제공: 얼추 맞는 말이다. 상속이란 어떤 변수와 함수를 하나의 유효 범위로 묶어 재정의하는 일에 불과. OO 전에도 C 프로그래머는 언어의 도움 없이 손수 구현 가능. NamedPoint가 Point를 포함하는 상위 집합으로, Point에 대응하는 멤버 변수의 순서가 그대로 유지되기 때문. C++의 단일 상속 구현 방식. 하지만 상속을 흉내내는 요령이지, 상속만큼 편리하지는 않았다. 다중 상속 구현하기란 어렵다. 진짜 OO에서는 업캐스팅이 암묵적으로 이뤄진다.
⇒ OO가 완전히 새로운 개념을 만들진 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다. 캡슐화에 대해서는 OO에 점수를 줄 수 없고, 상속에 대해서만 0.5점 정도를 부여할 수 있다.

  * 다형성: 유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 열기, 닫기, 읽기, 쓰기, 탐색의 다섯 가지 표준 함수를 제공할 것을 요구한다. FILE 데이터 구조는 이들 다섯 함수를 가리키는 포인터들을 포함한다.
함수를 가리키는 포인터를 응용한 것이 다형성이다. OO는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
함수 포인터는 위험하다. 포인터를 초기화하고, 포인터를 통해 모든 함수를 호출해야 하고, 그걸 까먹을 시 버그 발생. OO는 이런 관례를 없애주며, 실수할 위험이 없다. 따라서 다형성은 대수롭지 않은 일이 된다.
다형성이 가진 힘: 입출력 드라이버가 복사 프로그램의 플러그인처럼 작동. 1950년대 후반 우리는 이미 프로그램이 장치 독립적이어야 한다는 사실을 이미 배웠다.
플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 하지만 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 위험을 수반하기 때문이었다.
OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.
의존성 역전: main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하고, 중간 수준 함수는 다시 저수준 함수를 호출한다. 하지만 다형성이 끼어들면 인터페이스를 통해 F()함수를 호출. 의존성 역전: 심오해!
다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디서든 역전시킬 수 있다는 뜻. TODO: 네???
OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 제어흐름의 방향과 일치되도록 제한되지 않는다. 배포 독립성과 개발 독립성을 획득.
소프트웨어 아키텍트 관점에서 OO란: 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

6장 함수형 프로그래밍
--
함수형 프로그래밍의 개념: 프로그래밍 그 자체보다 앞서 등장. 람다 계산법→알론조 처치가 1930년대 발명.
리스프에서는 함수를 괄호 안에 넣는 방식으로 호출한다. 예를들면 (range)는 range 함수를 호출한다. 표현식 (fn [x] (* x x)) 는 익명 함수로, 곱셈 함수를 호출하면서 입력 인자를 두 번 전달한다. 즉, 입력의 제곱을 계산한다.
클로저와 자바 프로그램 사이의 극단적인 차이: 가변 변수 사용. 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다. i가 가변 변수다. 클로저에는 가변 변수가 없다. x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다. 함수형 언어에서 변수는 변경되지 않는다.
경합조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다. 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다. 락이 가변적이지 않다면 교착상태도 일어나지 않는다. 동시성 어플리케이션의 모든 문제가 가변 변수가 없다면 절대로 생기지 않는다.
스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다. 불변성이란 실현 가능한가?: 저장 공간이 무한하고, 프로세서의 속도가 무한히 빠르다고 전제하면 긍정적이다. 그렇지 않다면 실현 가능하지만 타협해야 한다.
가변성의 분리: 가장 중요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되고, 어떠한 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 상태 변경은 갖가지 동시성 문제에 노출하는 꼴이므로, 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다. (TODO: 트랜잭션 메모리?)
트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리 변수를 처리한다. 즉, 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들 변수를 보호한다.

swap! 함수는 전통적인 비교 및 스왑 알고리즘을 전략으로 사용한다. 먼저 counter 값을 읽은 후 inc 함수로 전달한다. inc 함수가 반환되면 counter의 값은 잠기게 되고 inc 함수로 전달했던 값과 비교한다. 같다면 inc 함수가 반환한 값이 counter에 저장되고 잠금은 해제된다. 같지 않다면 잠금을 해제한 후 이 전략을 처음부터 재시도한다. 하지만 여러 변수가 상호 의존하는 상황에서는 동시 업데이트와 교착상태 문제로부터 완벽히 보호해주지 못한다. 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.
이벤트 소싱: 계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장한다고 상상해보자. 발생한 모든 트랜잭션을 단순히 더한다. 이 전략에는 가변 변수가 하나도 필요 없다. 애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분할 것이다.
이벤트 소싱의 기본 발상: 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 상태의 시작점으로부터 모든 트랜잭션을 처리한다. 지름길: 매일 자정에 상태를 계산한 후 자정 이후의 트랜잭션만을 처리.
데이터 저장소에서 삭제되거나 변경되는 것은 하나도 없다. CRUD가 아니라 CR만 수행한다.

결론:
--
  * 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
  * 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
  * 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
  * 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시키고, 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.
  * 소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.
