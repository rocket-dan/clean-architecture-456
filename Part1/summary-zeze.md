# 21.10.02 1장

## 서문

아키텍처 규칙은 동일하다!\
이 사실이 놀라운 이유는 내가 지금까지 구축한 시스템들이 근본적으로 정말 다르기 때문이다.

왜?

나는 소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적이라는 결론을 내렸다.\
하드웨어 성능 변화에 따라 소프트웨어가 더 커진다는 변화는 있다.\
그러나 현재의 소프트웨어는 과거와 동일한 것들로 구성된다.\
여전히 if 문, 할당문, while 루프로 구성된다.\
코드는 여전히 순차, 분기, 반복 (sequence, selection, iteration) 의 집합체일 뿐이다\
→ 동시성, 함수형 언어의 패러다임 등의 변화는 무의미한가?

이처럼 코드가 변하지 않았다는 사실이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다.

하지만 바뀐게 딱 하나 있다. 그 시절의 우리는 이 규칙이 무엇인지 알지 못했기 때문에 규칙을 계속해서 어겼다.

이 책은 세월이 흘러도 변치않는 규칙에 관한것이다.

## 1부 - 소개

소프트웨어를 올바르게 만드는 일은 어렵다.\
제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 새로운 기능을 추가하거나 유지보수할 수 있다.\
그러나 우리가 보통 경험하는 것은 정 반대의 상황이다.

---

### 1장 - 설계와 아키텍처란?

설계 - design\
아키텍쳐 - architecture

둘 사이에 차이가 없다.\
흔히 아키텍쳐는 고수준, 설계는 저수준의 구조 또는 결정사항 등을 의미하지만 이러한 구분은 무의미\
저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소\
개별로는 존재할 수 없고 경계가 뚜렷하지 않으며 고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을뿐이다

- 목표는?\
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

좋은 설계란 - 고객의 요구를 만족시키는 데 드는 비용을 적게 유지할 수 있는 설계

- 사례 연구\
한 회사의 기간당 엔지니어 수 증가추이, 생산성 (LoC), 코드 라인당 비용을 비교 → 생산성 현저히 저하됨을 발견\
경영자의 시각에서는 월별 인건비가 기하급수적으로 증가\
하지만 어떤 조치를 취해야하나?

> 이들 개발자는 "코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!" 라는 흔해 빠진 거짓말에 속는다. 이렇게 속아 넘어간 개발자라면 나중에 코드를 정리하는 경우는 한 번도 없는데, 시장의 압박은 절대로 수그러들지 않기 때문이다.
> 

개발자가 속는 더 잘못된 거짓말은 "지저분한 코드를 작성하면 단기간에는 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아진다" 는 견해다.   ...   진실은 다음과 같다. 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.

TDD 를 사용했을때와 사용하지 않았을때의 실험 결과가 가장 생산성이 낮았음

빨리 가는 유일한 방법은 제대로 가는 것이다.

자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.

- 결론\
조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하는 것이 최고의 선택지\
이를 실행하려면 좋은 소프트웨어 아키텍처가 무엇인지 이해해야 함

---

### 2장 - 두 가지 가치에 대한 이야기

모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공하는데, 행위와 구조 (behavior and structure)가 바로 그것이다. 개발자는 두 가치 모두 높게 유지해야하는 책임이 있다.

- 행위\
프로그래머가 하는 아래와 같은 일
```
기능 명세서 등의 요구사항 문서화를 돕고
요구사항을 만족하도록 코드를 작성하고
요구사항을 위반할시 문제를 고치고
```

- 아키텍처\
소프트웨어는 변경하기 쉬워야한다.\
변경사항을 적용하는데 드는 어려움은 변경되는 범위(scope) 에 비례해야 하며, 변경사항의 형태(shape) 와는 관련이 없어야 한다.\
-> 범위와 형태의 의미..?\
소프트웨어 개발비용의 증가를 결정짓는 주된 요인은 변경사항의 범위와 형태의 차이에 있다.\
아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.\
따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.

- 더 높은 가치\
기능 vs 아키텍처 어느것의 가치가 더 높은가?\
관리자는 기능에 더 높은 가치를 둘것이고, 개발자도 관리자의 의견에 대체로 동조할 것이나 이는 잘못된 태도\
→ 완벽히 동작하나 수정이 불가능하다면 요구사항이 변경될 때 쓸모없게 됨\
→ 동작하지 않지만 변경이 쉬운 프로그램이라면 변경사항이 발생하더라도 동작하도록 유지보수가 가능\
실질적으로 변경이 불가능한 상태에 처할 때까지 시스템을 방치하는 것은 잘못된 태도

수정이 현실적으로 불가능한 시스템\
→ 변경에 드는 비용이 변경으로 창출되는 수익을 초과하는 경우

- 아이젠하워 매트릭스\
중요성과 긴급성에 관한 매트릭스\
![image](https://user-images.githubusercontent.com/5154845/135727659-7205ae30-7779-404f-8218-c025502a3d0e.png)

행위 - 긴급하지만 매번 중요하진 않음\
아키텍처 - 중요하지만 긴급하지 않음

우선순위
1. urgent, important - 행위, 아키텍처
2. not urgent, important - 아키텍처
3. urgent, not important - 행위
4. not urgent, not important

흔한 실수는 3번을 1번으로 격상시키는 경우\
관리자는 보통 아키텍처의 중요성을 평가할 만한 능력이 없는 경우가 많음 \
→ 소프트웨어 개발자를 고용하는 이유는 바로 이 딜레마를 해결하기 위해서\
아키텍처의 중요성을 설득하는 일은 개발팀이 해야할 일

- 아키텍처를 위해 투쟁하라\
아키텍처를 위해 투쟁하려면 싸움판에 뛰어들어야 한다.\
늘 투쟁이 발생한다.

소프트웨어 개발자인 당신도 이해관계자임을 명심하라.\
→ 그렇다면 어떻게 투쟁할 수 있을까? 효율적인 의사전달 방식은?\
→ 평소에 신뢰관계를 잘 쌓자. 작은 요구사항을 빠르게 피드백하는 것도 좋은 방법

아키텍처가 후순위가 되면 시스템 개발 비용이 증가하고, 현실적으로 유지보수가 불가능해진다. 이러한 상황이 발생했다면, 개발팀이 충분히 투쟁하지 않았다는 뜻이다.
