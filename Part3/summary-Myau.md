3부 설계 원칙
====
좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.  
**좋은 벽돌로 좋은 아키텍처를 정의하는 원칙: SOLID**    

SOLID: 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스로 결합하는 방법.  
(클래스: 함수와 데이터를 결합한 집합)    

SOLID 원칙의 목표는 중간 수준의 소프트웨어 구조에 대해:
  * 변경에 유연하다.
  * 이해하기 쉽다.  
많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.    

* SRP: 단일 책임 원칙 Single Responsibility Principle
    * 콘웨이 법칙에 따른 따름정리: 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
* OCP: 개방-폐쇄 원칙 Open-Closed Principle
    * 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 한다.
* LSP: 리스코프 치환 원칙 Liskov Substitution Principle
    * 상호 대체 가능한 구성요소를 이용해 소프트웨어를 만들 수 있으려면 이들 구성요소는 반드시 서로 치환 가능해야 한다.
* ISP: 인터페이스 분리 원칙 Interface Segregation Principle
    * 사용하지 않은 것에 의존하지 않아야 한다.
* DIP: 의존성 역전 원칙 Dependency Inversion Principle
    * 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.
  
⇒ 잘 모르는 사람은 Clean Software 책을 사라 (광고시간~)
      
       
       
7장 SRP Single Responsibility Principle 단일 책임 원칙
====
(하나의 일만 해야 한다 아님. 그건 더 저수준)
  
**단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.**
  
하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
  
액터actor: 변경을 원하는 사람
  
모듈이란? 소스파일, 일부 언어와 개발 환경에서는 단순히 함수와 데이터 구조로 구성된 응집된 집합.
  
응집된cohesive라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.
    
이를 위반하는 예시들을 보여주겠다.
  
**징후1. 우발적 중복**  
CFO, COO, CTO ⇒  
Employee  
+calculatePay  
+reportHours  
+save  
  
SRP 위반 ⇒ 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문.  

calculatePay()는 회계팀에서 기능을 정의하고, CFO 보고를 위해 사용한다.  

reportHours() 메서드는 인사팀에서 기능을 정의하고, COO 보고를 위해 사용한다.  

save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.  

⇒ Employee라는 단일 클래스에 배치해 버렸다! CFO 팀의 조치가 COO팀에 영향을 줄 수 있다.    
  
ex: calculatePay()와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 regulateHours()라는 메서드에 넣었다고 해보자.  

이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 했다고 하자. 반면 인사 COO팀에선 초과 근무를 제외한 업무 시간을 CFO팀과는 다른 목적으로 사용하기 때문에, 이같은 변경을 원치 않는다고 해 보자.
  
개발자는 calculatePay() 메서드가 regularHours()를 호출한다는 걸 발견하지만, reportHours()에서 호출된다는 걸 눈치채지 못한다. 돈이 낭비되고 COO는 격노한다...!
  
  
**징후2. 병합**
  
소스 파일에 많은 메서드를 포함할수록, 서로 다른 액터를 책임질수록 병합이 발생할 가능성은 더 높다.
  
데이터베이스의 Employee 테이블 스키마를 약간 수정하기로 결정하고, 인사 담당자가 속한 COO 팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 결정했다고 해보자. 두 다른 개발자가 서로의 작업을  알지 못한 채 Employee 클래스를 변경한다. 충돌! 병합! 아무리 훌륭한 병합이라도 위험이 따른다.
  
서로 다른 액터를 뒷받침하는 코드를 서로 분리해라.
  
**해결책**
  
메서드를 각기 다른 클래스로 이동시켜라. 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어 세 개의 클래스가 공유하도록 한다. 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다. 세 클래스는 서로의 존재를 몰라야 한다.
  
반면 이건 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 퍼사드Facade 패턴을 사용한다.
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8332d2b6-3274-4f46-bc80-b30b0080e81c/Untitled.png)
  
EmplyeeFacade에 코드는 거의 없다. 세 클래스 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
  
어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다. Employee 클래스에 가장 중요한 메서드를 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수 있다.
 
모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 근거하여 앞의 해결책에 반대할 수도 있다. 하지만 각 클래스 메서드 개수는 훨씬 많을 것이다.
  
여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지 전혀 알 수 없다.
  
  
**결론**

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 상위 두 수준에서도 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙 Common Closure Principle이 된다. 아키텍처 수준에서는 아키텍처 경계 Architectural Boundary의 생성을 책임지는 변경의 축이 된다.
  
8장 OCP: 개방-폐쇄 원칙
====
소프트웨어 개체artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
  
*사고 실험*
  
재무제표 웹 페이지 출력. 데이터 스크롤, 음수는 빨간색.
  
흑백 프린터 출력→페이지 번호와 머리글, 바닥글, 각 열 레이블, 음수는 괄호로.
  
얼마나 수정해야 할까? 0이어야 한다.
  
서로 다른 목적으로 변경되는 요소들을 적절하게 분리하고 (단일 책임 원칙SRP) 이들 요소 사이 의존성을 체계화(의존성 역전 원칙DIP)
  
  
보고서 생성은 두 개의 책임으로 분리.
  
1. 보고서용 데이터를 계산  
2. 웹으로 보여주거나 종이로 프린트
  
  
두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성 조직화. 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.
  
처리 과정을 클래스 단위로 분할하고, 클래스를 이중선으로 표시한 컴포넌트 단위로 구분해야 한다. 좌측 상단 컴포넌트 Controller와 우측 상단 Interactor, 우측 하단 Database 컴포넌트. 좌측 하단 Presenter와 View를 담당하는 네 가지 컴포넌트.
  
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f89d2c2b-7a67-4230-9d77-d9c331713f47/Untitled.png)
  
  
< I >는 인터페이스, < DS >는 데이터 구조. 화살표가 열려 있다면 사용 using 관계이며 닫혀 있다면 구현 implement 혹은 상속inheritance 관계이다.
  
모든 의존성이 소스 코드 의존성을 나타낸다.
  
화살표가 A에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않는다.
  
이중선은 화살표와 오직 한 방향으로만 교차한다.
  
모든 컴포넌트 관계는 단방향으로 이루어지고, 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
  
가장 높은 수준의 정책을 포함하는 (책 예시에선 Interactor)는 어떤 변경도 영향을 줄 수 없는 가장 보호받은 위치에. Controller는 Presenter와 View에 비해 중심적인 문제. 보호의 계층 구조가 '수준level'이라는 개념을 바탕으로 어떻게 생성되는지 주목하자. 이것이 아키텍처 수준에서 OCP가 동작하는 방식이다. 아키텍트는 기능이 어떻게how, 왜why, 언제when 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
  
  
**방향성 제어**
----
FinancialDataGeteway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 의존성을 역전시키기 위해서다. 인터페이스가 없었다면 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다. FinancialReportPresenter 인터페이스와 두개의 View 인터페이스도 같은 목적을 가진다.
  
**정보 은닉**
----
FinancialReportRequester 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해 존재한다. 아니라면 Controller는 FinancialEntities에 대해 추이 종속성transitive dependency를 가지게 된다.
  
⇒ 자신이 직접 사용하지 않는 요소에는 절대 의존해서는 안 된다는 소프트웨어 원칙을 위반하게 된다. 인터페이스 분리 원칙ISP과 공통 재사용 원칙CRP를 설명할 떄 다시한번 설명한다.
  
Controller로부터 Interactor를 보호하는 게 우선이지만, Interactor의 변경으로부터 Controller도 보호되기를 바란다. 따라서 Interactor 내부를 은닉한다.
  
  
**결론**
----
OCP는 시스템 아키텍처를 떠받치는 원동력 중 하나다. 시스템 확장 쉬운 동시 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 게 목적이다. 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.
  
9장: LSP: 리스코프 치환 원칙
====
  
1988 바바라 리스코프는 하위 타입을 아래와 같이 정의했다.
  
> 여기에서 필요한 것은 다음과 같은 치환substitution 원칙이다. S 타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
  
**상속을 사용하도록 가이드하기**
----
License라는 클래스가 있다고 해보자. calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다. License에는 PersonalLicense와 BusinessLicense 두 가지 '하위 타입'이 존재한다. 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/346e7df8-dbc4-4a0e-9249-c121039fb31f/Untitled.png)
  
이 설계는 LSP 준수→ Billing 어플리케이션 행위가 License 하위 타입 중 무엇을 사용하는지에 의존하지 않기 때문. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.
  
정사각형/직사각형 문제
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ced57271-ea4d-40e3-bd01-9517146caa1c/Untitled.png)
  
Square는 Rectangle의 하위 타입으로 적합하지 않다. Rectangle의 높이와 너비는 독립적 변경이 가능한 반면, Square의 높너비는 반드시 함께 변경되기 때문이다.
  
LSP 위반을 막기 위한 유일한 방법은 (if문 등을 이용해서) Rectangle이 실제로 Square인지를 검사하는 메커니즘을 User에 추가하는 것이다. 하지만 그러면 User 행위가 사용 타입에 의존하게 되므로, 타입을 서로 치환할 수 없다.
  
**LSP와 아키텍처**
----
초창기: LSP는 상속 사용 가이드 정도로 간주되었다. 하지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.
  
여기서 말하는 인터페이스: 자바같은 애는 인터페이스 하나와 이를 구현하는 여러 개 클래스, 루비는 동일한 메서드 시그니처를 공유하는 여러 개의 클래스, 동일한 REST 인터페이스에 응답하는 서비스 집단...
  
더 많은 경우 LSP 적용 가능.
  
잘 이해하려면: 어겼을 때 무슨 일이 일어날까?
  
**LSP 위배 사례**
----
택시업체는 신경 안써요! 상황에 가장 적합한 택시를 불러주세요. → REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다.
  
REST 서비스 URI가 운전기사 데이터베이스에 저장되어 있다면 → 시스템이 고객에게 알맞은 기사를 선택하면, 해당 기사 레코드로부터 URI 정보를 얻은 다음, 해당 기사를 파견.
  
택시기사인 Bob의 파견 URI는 다음과 같다
  
> purplecab.com/driver/Bob
  
파견에 필요한 정보를 덧붙이고 PUT 방식으로 호출한다.
  
  
> purplecab.com/driver/Bob  
> /pickupAddress/24 Maple St.  
> /pickupTime/153  
> /destination/ORD  
  
  
다양한 택시업체는 동일 REST 인터페이스를 반드시 준수해야 한다. 서로 다른 택시업체가 pickupAdress, pickupTime, destination 필드를 모두 동일하게 처리해야 한다.
  
  
애크미ACME사에서 서비스 사양서를 제대로 읽지 않은 프로그래머 고용→destination 필드를 dest로 축약해서 사용했다. 하지만 애크미가 가장 큰 택시회사야!!
  
→ 이런, 얘네 예외 사항을 처리하는 로직을 추가해야 해.
  
  
> if (driver.getDispatchUri().startsWith("acme.com"))...
  
⇒ 파견 URI를 키로 사용하는 설정용 데이터베이스를 이용하는 파견 명령 생성 모듈을 만들어야 할 수도 있다. 설정 정보는 대체로 아래와 같을 것이다.
  
  
> URI Dispatch Format  
> [Acme.com](http://Acme.com) /pickUpAdress/%s/pickupTime/%s/dest/%s  
> *.* /pickUpAdress/%s/pickupTime/%s/destination/%s
  
  
또한 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.
  
**결론**
----
LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.
  
  
10장 ISP: 인터페이스 분리 원칙
====
인터페이스 분리 원칙은 다음과 같은 다이어그램에서 유래
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29820446-6e33-4105-9ec0-631bfdc8912a/Untitled.png)
  
User1은 op1만을, User2는 op2만을, User3은 op3만을 사용한다고 가정해 보자.
  
그리고 OPS가 정적 타입 언어로 작성된 클래스라고 해보자. User1은 op2 op3은 전혀 사용하지 않는데도 User1의 소스 코드는 이 두 메서드에 의존하게 된다. 이러한 의존성으로 인해 OPS 클래스에서 op2의 소스 코드가 변경되면 User1도 다시 컴파일한 후 새로 배포해야 한다.
  
오퍼레이션을 인터페이스 단위로 분리하여 해결.
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56a050af-997b-457c-89f3-f1146b3e9e39/Untitled.png)
  
User1의 소스 코드는 U1Ops와 op1에는 의존하지만 OPS에는 의존하지 않는다.
  
  
**ISP와 언어**
----
언어 타입에 의존. 정적 타입 언어는 사용자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제한다. 이처럼 소스 코드에 포함된included 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다. 루비나 파이썬과 같은 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다. 따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다. 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 바로 이 때문이다.
  
⇒ ISP는 아키텍처가 아니라, 언어와 관련된 문제?
  
  
**ISP와 아키텍처**
----
근본적인 동기:
  
필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해롭다. 불필요한 재컴파일과 재배포를 강제한다.
  
더 고수준→S 시스템 구축에 참여하는 아키텍트가 F라는 프레임워크를 시스템이 도입하기 원한다. F 프레임워크 개발자는 D 데이터베이스를 반드시 사용하도록 만들었다고 하자. S→F→D의 의존성. D 내부가 변경되면, F를 재배포해야 할 수도 있고, S까지 재배포해야 할 지 모른다. 불필요한 기능이 변경되더라도!
  
  
**결론**
----
불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.
  
→ 13장 "컴포넌트 응집도"에서 공통 재사용 원칙을 논할 때 To be continued...
  
  
11장 DIP: 의존성 역전 원칙
====
의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
  
자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. 구체적 대상에는 절대로 의존해서는 안 된다.
  
루비나 파이썬과 같은 동적 타입 언어에도 동일한 규칙 적용. 소스코드 의존 관계에서 구체 모듈은 참조해서는 안 된다. 하지만 구체 모듈이 뭔지 정의하기 다소 어려워! 구현된 모듈이라면 참조하지 않기가 특히 어렵다. 
  
규칙으로 보기엔 비현실적. 소프트웨어 시스템은 많은 구체적 장치에 반드시 의존하기 때문이다. ex: Java의 String은 구체 클래스이며, 추상 클래스로 만든다는 건 현실성이 없다.
  
반면, String 클래스는 매우 안정적이다. 변경되는 일이 없으며, 있더라도 엄격하게 통제된다. 따라서 DIP를 논할 때 운영체제, 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시한다. 변경되지 않는다면 의존할 수 있다.
  
변동성이 큰 구체적 요소에 대한 의존성을 피하자. 우리가 만드는 중이라 자꾸 변하는 애들 말이다.
  
  
**안정된 추상화**
----
추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반면 구현체 변경은 인터페이스 변경이 대다수의 경우 필요없다. 따라서 인터페이스는 구현체보다 변동성이 낮다.
 
뛰어난 소프트웨어 설계자와 아키텍트: 인터페이스의 변동성을 낮추기 위해 애쓴다. 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다. 소프트웨어 설계의 기본.
  
안정된 소프트웨어 아키텍처: 변동성 큰 구현체 의존 지양, 안정된 추상 인터페이스 선호.
  
* 변동성이 큰 구체 클래스를 참조하지 마라. 대신 추상 인터페이스를 참조하라. 언어가 정적이든 동적이든 모두. 객체 생성 방식을 강하게 제약, 추상 팩토리를 사용하도록 강제한다.
* 변동성이 큰 구체 클래스로부터 파생하지 말라. 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중 가장 강력한 동시 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다. 동적 타입 언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이 없다. 신중에 신중 거듭.
* 구체 함수를 오버라이드하지 말라. 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 의존성을 제거할 수 없고, 의존성을 상속하게 된다. 추상 함수로 선언하고 구현체들에서 각자 용도에 맞게 구현하라.
* 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라. DIP 원칙.
  
  
**팩토리**

변동성이 큰 구체적 객체는 특별히 주의해서 생성해야 한다. 객체 생성이 해당 객체 구체적 정의 코드에 대해 소스 코드 의존성이 발생하기 때문.
  
추상 팩토리→ 객체 지향 언어에서 바람직하지 못한 의존성 처리.
  
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46e5c5ac-5d1f-49a6-be9e-d343390d8b10/Untitled.png)
  
Application은 Service 인터페이스를 통해 ConcreteImple을 사용, Apllication에서는 ConcreteImple의 인스턴스를 생성해야 한다. ConcreteImpl에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application은 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다. ServiceFactory로부터 파생된 ServiceFactoryImpl에서 구현된다. ServiceFactoryImpl 구현체가 ConcreteImpl 인스턴스 생성 후 Service 타입으로 반환한다.
  
곡선은 아키텍처 경계: 구체적인 것들로부터 추상적인 것들을 분리한다. 소스 코드 의존성은 모두 한 방향, 즉 추상적인 쪽으로 향한다.
  
곡선은 시스템을 추상/구체 컴포넌트로 분리한다. 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
  
제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다.→의존성 역전.
  
  
**구체 컴포넌트**

구체적 의존성이 하나 있고(ServiceFactoryImpl 구체 클래스가 ConcreteImpl 구체 클래스에 의존) DIP에 위반된다. 일반적. 모두 없앨 수는 없다. 하지만 위배하는 클래스를 적은 수의 구체 컴포넌트 내부로 모을 수 있고 이를 통해 시스템 나머지 부분과 분리할 수 있다.
  
구체 컴포넌트를 최소한 하나는 포함: main함수를 포함하는 Main. main함수는 ServiceFactoryImpl의 인스턴스 생성 후 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장. Application은 이 전역 변수를 이용해서 ServiceFactoryImpl 인스턴스에 접근
  
  
**결론**

고수준 아키텍처에서 DIP는 몇 번이고 계속 등장할 것이다. DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다. 11.1의 곡선은 이후 장에서 아키텍처 경계가 될 것이다. 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙Dependency Rule이라 부를 것이다.
